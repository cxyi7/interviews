1. 同步和异步的区别
js是单线程的，同步代码会阻塞运行，异步不会阻塞

2. 手写Promise加载图片
```
loadImg(url) {
	return new Promise((resolve,reject) => {
		const img = document.createElement('img')
		img.onload = () => {
			resolve(img)
		}
		img.onerror = () => {
			resolve('加载出错了')
		}
		img.src = url
	})
}
```

3. 讲讲event loop（事件循环/事件轮询）机制
   1. 同步代码，一行一行放在Call Stack执行
   2. 遇到异步代码，会先记录下，等待时机（定时，网络请求等）
   3. 时机到了，就移动到Callback Queue
   4. 当Call Stack 为空（即同步代码执行完），event loop开始工作
   5. 轮询查找Callback Queue，如有任务就将其移动到Call Stack 执行
   6. 然后继续轮询查找

4. JS如何执行
   1. 从前到后，一行一行执行
   2. 如果某一行执行报错，则停止下面代码的执行
   3. 先把同步代码执行完，再执行异步代码

5. Promise的三种状态
   1. pending 状态下，不会触发then和catch
   2. resolved 状态下，会触发后续的then回调函数
   3. rejected 状态下，会触发后续的catch回调函数
   
6. Promise中的then方法和catch方法对状态的影向
   1. then正常返回resolved，里面有报错则返回rejected
   2. catch正常返回resolved，里面有报错则返回rejected

7. async/await 和 Promise 的关系
   1. 执行async函数，返回的是Promise对象
   2. await 相当于Promise的then方法
   3. try..catch 用来捕获异常，替代了Promise的catch

8. 一道笔试题，输出执行结果
```
async function test1() {
	console.log('test1 start') //2
	await test2()
	console.log('test2 end') //5
	await test3()
	console.log('test3 end') //7
}

async function test2() {
	console.log('test2 start') //3
}

async function test3() {
	console.log('test3 start') //6 
}

console.log('script start')  //1
test1()
console.log('script end') //4
```

9. 宏任务和微任务
   1.  宏任务： setTimeout,setInterval, Ajax, DOM事件,setImmediate,I/O（Node.js）
   2.  微任务： Promise.then,MutaionObserve, process.nextTick
   注意： 定时器的时间是指从执行定时器开始计时的，当时间到了之后就会把这个任务放到Callback Queue中
   
   二者的执行时间：
   微任务 --》 DOM渲染 --》 宏任务
   
   执行顺序是：
   1. Call Stack清空
   2. 执行当前的微任务
   3. 尝试渲染DOM
   4. 触发event loop机制
```
验证执行顺序
// 修改 DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
    .append($p1)
    .append($p2)
    .append($p3)

// // 微任务：渲染之前执行（DOM 结构已更新）
Promise.resolve().then(() => {
    const length = $('#container').children().length
    alert(`micro task ${length}`)
})

// 宏任务：渲染之后执行（DOM 结构已更新）
setTimeout(() => {
    const length = $('#container').children().length
    alert(`macro task ${length}`)
})

```

10. 一道题目，输出执行顺序
```
async function async1 () {
  console.log('async1 start') // 2
  await async2() 
  console.log('async1 end') // 6
}

async function async2 () {
  console.log('async2') // 3 
}

console.log('script start') // 1 

setTimeout(function () { 
  console.log('setTimeout') // 8
}, 0)

async1()

new Promise (function (resolve) { 
  console.log('promise1') // 4
  resolve()
}).then (function () { 
  console.log('promise2') // 7
})

console.log('script end') // 5 
```

11. 手写Promise
```
class myPromise{
	state = 'pending'   //状态 'pending'  'fulfilled' 'rejected'
	value = undefined   //成功回调的值
	reason = undefined   //失败回调的值
	
	resolveCallbacks = []  // pending状态下，存储成功的回调
	rejectCallbacks = []   // pending状态下，存储失败的回调
	
	constructor(fn) {
		const resolveHandler = (value) => {
			if (this.state === 'pending') {
				this.state = 'fulfilled'
				this.value = value
				this.resolveCallbacks.forEach(fn => fn(this.value))
			}
		}
		const rejectHandler = (reason) => {
			if (this.state === 'pending') {
				this.state = 'rejected'
				this.reason = reason
				this.rejectCallbacks.forEach(fn => fn(this.reason))
			}
		}
		
		try{
			fn(resolveHandler,rejectHandler)
		} catch (err) {
			rejectHandler(err)
		}
	}
	
	then(fn1, fn2) {
		fn1 = typeof fn1 === 'function' ? fn1 : (v) => v
		fn2 = typeof fn2 === 'function' ? fn2 : (e) => e
		
		if (this.state === 'pending') {
			const p1 = new myPromise((resolve,reject) => {
				this.resolveCallbacks.push(() => {
					try {
						const newValue = fn1(this.value)
						resolve(newValue)
					} catch (e) {
						reject(e)
					}
				})
				this.rejectCallbacks.push(() => {
					try{
						const newReason = fn2(this.reason)
						reject(newReason)
					} catch (e) {
						reject(e)
					}
				})
			})
			return p1
		}
		if (this.state === 'fulfilled') {
			const p1 = new myPromise((resolve,reject) => {
				try {
					const newValue = fn1(this.value)
					resolve(newValue)
				} catch (e) {
					reject(e)
				}
			})
			return p1
		}
		if (this.state === 'rejected') {
			const p1 = new myPromise((resolve,reject) => {
				try{
					const newReason = fn2(this.reason)
					reject(newReason)
				} catch (e) {
					reject(e)
				}
			})
			return p1
		}
	}
	catch(fn) {
		return this.then(null, fn)
	}
}

myPromise.resolve = function(value) {
	return new myPromise((resolve,reject) => resolve(value))
}
myPromise.reject = function(reason) {
	return new myPromise((resolve,reject) => reject(reason))
}

myPromise.all = function(promiseList = []) {
	if(!Array.isArray(promiseList)) throw new typeError('请输入一个数组')
	const p1 = new myPromise((resolve,reject) => {
		let resolvedCount = 0
		let result = []
		const length = promiseList.length
		promiseList.forEach((p,index) => {
			p.then(data => {
				result[index] = data
				resolvedCount ++
				if (length === resolveCount) {
					resolve(result)
				}
			}).catch(err => {
				reject(err)
			})
		})
	})
	return p1
}

myPromise.race = function(promiseList = []) {
	if(!Array.isArray(promiseList)) throw new typeError('请输入一个数组')
	let resolved = false
	const p1 = new myPromise((resolve,reject) => {
		promiseList.forEach(p => {
			p.then(data => {
				if(!resolved) {
					resolve(data)
					resolved = true
				}
			}).catch(err => {
				if(!resolved) {
					reject(data)
					resolved = true
				}
			})
		})
	})
	return p1
}

补充：catch后无法再传递下去
```

12. 获取DOM节点的几种方式
```
document.getElementById() //单个
document.getElementsByTagName() //集合
document.getElementsByClassName() //集合
document.querySelector() // 单个
document.querySelectorAll() //集合
```

13. property和attribute的区别
    property: 修改对象属性，但不会体现到html结构中
	attribute: 修改html属性，会改变html结构
```
<div>s</div>
const b = document.querySelector('div')
b.a = 100  //不会体现在Html中
b.setAttribute('b', 100) //会体现的html中
```

14. DOM性能优化
    1. DOM查询缓存
	2. 对于DOM的多次操作，使用文档片段(createDocumentFragment)，操作完成后再将该片段插入到DOM中
	3. 对于要操作的DOM，先克隆(cloneNode)，对克隆的节点进行操作，然后再使用replaceChild方法将克隆节点替换原先的
	4. 对于DOM的多种样式操作，可以拼接在一起一次操作

15. location的一些相关知识
    1. href: 完整的url
	2. protocol: url协议
	3. pathname: url路径名
	4. host: 主机名和端口
	5. hostname: 主机名
	6. hash: url的hash
	7. search: url的查询部分

16. 编写一个通用的事件监听函数
```
<!-- 普通绑定和代理绑定 -->
function bindEvent(ele, type, selector, fn) {
	if (fn == null) {
		fn = selector
		selector = null
	}
	ele.addEventListener(type, event => {
		const target = event.target
		if(selector) {
			if (target.matches(selector)) {
				fn.call(target, event)
			}
		} else {
			fn.call(ele, event)
		}
	})
}

补充： event.preventDefault(); 阻止默认事件发生
```

17. 描述事件冒泡的流程
在嵌套的父子元素中，子元素的事件会一层一层向上传递，一直到顶层元素window对象
补充：event.stopPropagation();  可以阻止捕获和冒泡

18. 什么是事件代理
事件代理就是在父元素上绑定事件，然后通过父元素的事件来处理子元素的相关操作。
好处是代码简洁，减少浏览器内存

19. 手写XMLHttpRequest
```
const xhr = new XMLHttpRequest()
xhr.open('GET', '/api', true) // true代表异步
let res
xhr.onreadystatechange = function () {
	if(xhr.readState === 4) {
		if (xhr.status === 200) {
			console.log(xhr.responseText)
			res = xhr.responseText
		} else {
			console.log('其他情况')
		}
	}
}
xhr.send(res)
```

20. readyState的几种状态
    1. 状态0表示尚未调用open方法
	2. 状态1表示open方法已经被调用
	3. 状态2表示send方法已经被调用，header已经被接收
	4. 状态3表示下载中，responseText中有部分内容
	5. 状态4表示下载完成

21. 什么是同源策略
同源是指：协议，端口，域名三者必须保持一致
当Ajax发送请求时，浏览器要求当前网页和server必须同源

22. 那些情况可以无视同源策略
    1. 加载图片
	2. 加载css
	3. 加载js

23. 如何理解jsonp
js是可以跨域的，服务器可以任意动态拼接数据返回，只要符合js文件格式。
使用js发送跨域请求，服务器根据发送的请求返回数据到callback函数中，然后前端定义好相应的函数来执行返回的函数即可

24. 关于axios了解那些
    1. 关于axios，是一个基于promise的请求库，可以用在Node和浏览器中
	2. 在浏览器中创建XMLHttpRequest，在node中创建http请求
	3. 拦截请求和响应

25. 如何封装axios
    1. 获取axios实例，实例里面可以设置baseurl和timeout超时时间还有headers
	2. 设置拦截器，在请求拦截中可以设置url，method，baseurl，transformRequest（在发送前转换数据格式），headers，params以及data等
	3. 在响应拦截中可以设置data，status，statusText，headers，confing和request（生成此次响应的请求）

26. 关于cookie，localStorage和sessionStorage的理解
    1. localStorage和sessionStorage最大可存储5M。API可直接使用setItem，getItem和removeItem。并且都不会随着http请求发送出去
	2. localStorage数据会永久有效，除非手动或代码删除
	3. sessionStorage数据只存在于当前会话中，关闭页面或浏览器都会被清除
	4. cookie一般由服务器生成，可以设置失效时间。若没有设置时间，则关闭浏览器就会失效。存放数据大小为4k左右。会随着HTTP请求发送出去。通过document.cookie来修改

27. HTTP常见的状态码有那些
    1. 1xx 服务器收到请求
	2. 2xx 请求成功
	3. 3xx 重定向
	4. 4xx 客户端错误
	5. 5xx 服务端错误
	常见的状态码：
	1. 200 请求成功
	2. 301 永久重定向（配合location，浏览器自动处理）
	3. 302 临时重定向（配合location，浏览器自动处理）
	4. 304 资源未被修改
	5. 404 资源未找到
	6. 403 没有权限
	7. 500 服务器错误
	8. 504 网关超时

28. HTTP常见的headers有那些
    Request Headers
	1. Accept 浏览器可接收的数据格式
	2. Accept-Encoding 浏览器可接收的压缩算法，如gZIP
	3. Accept-Languange 浏览器可接收的语言，如zh-CN
	4. Connection: keep-alive 一次TCP连接重复使用
	5. cookie
	6. Host
	7. User-Agent 浏览器信息
	8. Content-type 发送数据的格式，如application/json
	
	Response Headers
	1. Content-type 返回数据的格式，如application/json
	2. Content-length 返回数据的大小，比如多少字节
	3. Content-Encoding 返回数据的压缩算法，如gzip
	4. Set-Cookie 设置cookie

29. 什么是Restful API
    传统的api设计是把每个url当成一个功能，而Restful api是把每个url当成一个唯一的资源
	通过get(获取数据)，post(新建数据)，patch/put(更新数据)以及delete(删除数据)来判断对资源的操作，尽量不使用url参数
  
30. 描述一下HTTP的缓存机制
    为什么要使用缓存？ 可以减少网络请求的数量和体积，提高页面显示速度，使用户体验更好
	
	那些资源可以被缓存？ 静态资源（js，css，img）
	
	什么是强制缓存？
    设置Cache-control(Response Headers中)：max-age(设置过期时间)，no-cache(强制向服务器发送请求，由服务器判断该资源是否有更新，有则返回新内容，没有则使用缓存)，no-store(不用本地缓存，也不使用服务端的缓存措施)，private(针对个人用户)，public(允许中间代理或路由进行缓存处理)
	
	什么是协商缓存？
	由服务器判断客户端资源是否和服务端资源一样，一致则返回304，否则返回200和最新的资源
	第一次请求时，会返回资源和资源标识，通过判断这个资源标识来辨别资源是否有更新
	资源标识(Response Headers中)：
	1. Last-Modified 资源的最后修改时间
	2. Etag 资源的唯一标识
	3. 优先使用Etag
	4. Last-Modified只能精确到秒级
	5. 如果资源被重复生成，而内容不变，使用Etag更精准

31. 刷新状态对于缓存的影响
    1. 正常操作： 地址栏输入url，跳转链接，前进后退等  -->  强制和协商都有效
	2. 手动刷新： F5，点击刷新按钮，右击菜单刷新  --> 强制失效，协商有效
	3. 强制刷新： ctrl+f5 --> 强制和协商都失效