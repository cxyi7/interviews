1. 同步和异步的区别
js是单线程的，同步代码会阻塞运行，异步不会阻塞

2. 手写Promise加载图片
```
loadImg(url) {
	return new Promise((resolve,reject) => {
		const img = document.createElement('img')
		img.onload = () => {
			resolve(img)
		}
		img.onerror = () => {
			resolve('加载出错了')
		}
		img.src = url
	})
}
```

3. 讲讲event loop（事件循环/事件轮询）机制
   1. 同步代码，一行一行放在Call Stack执行
   2. 遇到异步代码，会先记录下，等待时机（定时，网络请求等）
   3. 时机到了，就移动到Callback Queue
   4. 当Call Stack 为空（即同步代码执行完），event loop开始工作
   5. 轮询查找Callback Queue，如有任务就将其移动到Call Stack 执行
   6. 然后继续轮询查找

4. JS如何执行
   1. 从前到后，一行一行执行
   2. 如果某一行执行报错，则停止下面代码的执行
   3. 先把同步代码执行完，再执行异步代码

5. Promise的三种状态
   1. pending 状态下，不会触发then和catch
   2. resolved 状态下，会触发后续的then回调函数
   3. rejected 状态下，会触发后续的catch回调函数
   
6. Promise中的then方法和catch方法对状态的影向
   1. then正常返回resolved，里面有报错则返回rejected
   2. catch正常返回resolved，里面有报错则返回rejected

7. async/await 和 Promise 的关系
   1. 执行async函数，返回的是Promise对象
   2. await 相当于Promise的then方法
   3. try..catch 用来捕获异常，替代了Promise的catch

8. 一道笔试题，输出执行结果
```
async function test1() {
	console.log('test1 start') //2
	await test2()
	console.log('test2 end') //5
	await test3()
	console.log('test3 end') //7
}

async function test2() {
	console.log('test2 start') //3
}

async function test3() {
	console.log('test3 start') //6 
}

console.log('script start')  //1
test1()
console.log('script end') //4
```

9. 宏任务和微任务
   1.  宏任务： setTimeout,setInterval, Ajax, DOM事件,setImmediate,I/O（Node.js）
   2.  微任务： Promise.then,MutaionObserve, process.nextTick
   注意： 定时器的时间是指从执行定时器开始计时的，当时间到了之后就会把这个任务放到Callback Queue中
   
   二者的执行时间：
   微任务 --》 DOM渲染 --》 宏任务
   
   执行顺序是：
   1. Call Stack清空
   2. 执行当前的微任务
   3. 尝试渲染DOM
   4. 触发event loop机制
```
验证执行顺序
// 修改 DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
    .append($p1)
    .append($p2)
    .append($p3)

// // 微任务：渲染之前执行（DOM 结构已更新）
Promise.resolve().then(() => {
    const length = $('#container').children().length
    alert(`micro task ${length}`)
})

// 宏任务：渲染之后执行（DOM 结构已更新）
setTimeout(() => {
    const length = $('#container').children().length
    alert(`macro task ${length}`)
})

```

10. 一道题目，输出执行顺序
```
async function async1 () {
  console.log('async1 start') // 2
  await async2() 
  console.log('async1 end') // 6
}

async function async2 () {
  console.log('async2') // 3 
}

console.log('script start') // 1 

setTimeout(function () { 
  console.log('setTimeout') // 8
}, 0)

async1()

new Promise (function (resolve) { 
  console.log('promise1') // 4
  resolve()
}).then (function () { 
  console.log('promise2') // 7
})

console.log('script end') // 5 
```

11. 手写Promise
```
class myPromise{
	state = 'pending'   //状态 'pending'  'fulfilled' 'rejected'
	value = undefined   //成功回调的值
	reason = undefined   //失败回调的值
	
	resolveCallbacks = []  // pending状态下，存储成功的回调
	rejectCallbacks = []   // pending状态下，存储失败的回调
	
	constructor(fn) {
		const resolveHandler = (value) => {
			if (this.state === 'pending') {
				this.state = 'fulfilled'
				this.value = value
				this.resolveCallbacks.forEach(fn => fn(this.value))
			}
		}
		const rejectHandler = (reason) => {
			if (this.state === 'pending') {
				this.state = 'rejected'
				this.reason = reason
				this.rejectCallbacks.forEach(fn => fn(this.reason))
			}
		}
		
		try{
			fn(resolveHandler,rejectHandler)
		} catch (err) {
			rejectHandler(err)
		}
	}
	
	then(fn1, fn2) {
		fn1 = typeof fn1 === 'function' ? fn1 : (v) => v
		fn2 = typeof fn2 === 'function' ? fn2 : (e) => e
		
		if (this.state === 'pending') {
			const p1 = new myPromise((resolve,reject) => {
				this.resolveCallbacks.push(() => {
					try {
						const newValue = fn1(this.value)
						resolve(newValue)
					} catch (e) {
						reject(e)
					}
				})
				this.rejectCallbacks.push(() => {
					try{
						const newReason = fn2(this.reason)
						reject(newReason)
					} catch (e) {
						reject(e)
					}
				})
			})
			return p1
		}
		if (this.state === 'fulfilled') {
			const p1 = new myPromise((resolve,reject) => {
				try {
					const newValue = fn1(this.value)
					resolve(newValue)
				} catch (e) {
					reject(e)
				}
			})
			return p1
		}
		if (this.state === 'rejected') {
			const p1 = new myPromise((resolve,reject) => {
				try{
					const newReason = fn2(this.reason)
					reject(newReason)
				} catch (e) {
					reject(e)
				}
			})
			return p1
		}
	}
	catch(fn) {
		return this.then(null, fn)
	}
}
```